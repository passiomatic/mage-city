# -*- coding: utf-8 -*-
import os
import sys
import json
import struct
import base64
import io
import urlparse
from functools import partial
from optparse import OptionParser, make_option
from PIL import Image

BOILERPLATE = """
-- This file has been generated by the Elmify utility. Sample usage:
-- $ python elmify.py /path/to/YourLevel.json .

module Levels.%s exposing (..)

import Color exposing (rgb)
import Math.Vector2 exposing (vec2)
import Tiled
import Collision exposing (rectangle)

"""


SRC_DIR = 'src/Levels'

#INDENT = " " * 4

# Tiled render order
RIGHT_DOWN, RIGHT_UP, LEFT_DOWN, LEFT_UP = "right-down", "right-up", "left-down", "left-up"

# Serializers for basic Elm types

def serialize_string(v):
    return '"%s"' % v

def serialize_float(v):
    return '%f' % v

def serialize_int(v):
    return '%d' % v

def serialize_bool(v):
    return "True" if v else "False"

def serialize_list(fields):
    return "[" + ", ".join(map(str, fields)) + "]"

def serialize_record(fields):
    l = ["%s = %s" % (k, serialize_value(v)) for (k, v) in fields.items()]
    return "{" + ", ".join(l) + "}"

def serialize_tuple(values):
    l = [serialize_value(v) for v in values]
    return "(" + ", ".join(l) + ")"

# Serialize a type annotation
def serialize_type(k, v):
    return "%s : %s" % (k, v)

# Pass value as-is
class Identity(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        return self.v

# There's no obvious mapping from Python to Elm Color
#   type, so build a translator
class Color(object):
    def __init__(self, v):
        self.rgb = struct.unpack('BBB', v.lstrip('#').decode('hex'))
    def serialize(self, _):
        r, g, b = self.rgb
        return 'rgb %d %d %d' % (r, g, b)

# There's no obvious mapping from Python to Elm Collision.Rectangle
#   type, so build a translator
class Rectangle(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        cx, cy, w, h = self.v
        return 'rectangle (vec2 %d %d) (vec2 %d %d)' % (cx, cy, w, h)

# There's no obvious mapping from Python to Elm Vec2
#   type, so build a translator
class Vec2(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        w, h = self.v
        return 'vec2 %d %d' % (w, h)

# class Asset(object):
#     def __init__(self, v):
#         self.v = v
#     def serialize(self, _):
#         return serialize_tuple(self.v)

# The top serializer, this calls all the serializers above.
#   Lists, records and tuple serializers can also call
#   serialize_value() for each element
def serialize_value(v):
    t = type(v)
    if t == str or t == unicode:
        serializer = serialize_string
    elif t == int:
        serializer = serialize_int
    elif t == float:
        serializer = serialize_float
    elif t == list:
        serializer = serialize_list
    elif t == bool:
        serializer = serialize_bool
    elif t == tuple:
        serializer = serialize_tuple
    # Special serializers
    elif t in (Color, Identity, Rectangle, Vec2):
        serializer = v.serialize
    else:
        raise TypeError("Cannot find serializer for " + v)

    return serializer(v)

# Tiled stuff

def serialize_tile_layer(level, layer):

    # Convert in px
    w = layer['width'] * level['tilewidth']
    h = layer['height'] * level['tileheight']

    offset_x = layer['offsetx'] if 'offsetx' in layer else 0
    offset_y = layer['offsety'] if 'offsety' in layer else 0

    # Calculate abs. position
    x = offset_x + w / 2
    y = h / 2 - offset_y

    name = layer['name']
    #filename = get_slug(level['name'], name, "lut.png")

    # Save LUT data
    layer['lut'] = encode_tile_data((layer['width'], layer['height']), level['tileset_size'], layer['data'])

    fields = {
        "name"      : name,
        "size"      : Vec2((w, h)),
        # TODO "opacity"   : layer['opacity'],
        "visible"   : layer['visible'],
        #"offset"    : Vec2((offset_x, offset_y)),
        "position"  : Vec2((x, y)),
        "lutName" : "%s.%s" % (level['name'], name)
    }
    return serialize_record(fields)


def serialize_obstacle_layer(level, layer):

    level_h = level['height'] * level['tileheight']

    def convert_object(object):
        # Coordinate conversion
        if level['renderorder'] == RIGHT_DOWN:
            # Find center
            w = object['width']
            h = object['height']
            cx = object['x'] + w / 2
            # Flip Y
            cy = level_h - object['y'] - h / 2
        else:
            raise ValueError("Unsupported rendering order" + order)

        object['rect'] = Rectangle((cx, cy, w, h))

        # Remove unused keys
        del object['width']
        del object['height']
        del object['x']
        del object['y']
        del object['type']
        del object['rotation']
        del object['visible']

        return object

    fields = map(serialize_record,
                map(convert_object, layer['objects']))
    return serialize_list(fields)


# def serialize_object(object):
#
#     fields = {
#         "name"      : object['name'],
#         #"id"        : object['id'],
#         "x"         : object['x'],
#         "y"         : object['y'],
#         "width"     : object['width'],
#         "height"    : object['height'],
#         #"rotation"  : object['rotation'],
#         #"visible"   : object['visible']
#
#         # TODO Add circle, polygon support
#     }
#     return serialize_record(fields)

# def serialize_tileset(tileset):
#     fields = {
#         "name"      : tileset['name'],
#         "startId"   : tileset['firstgid'],
#         "image"     : tileset['image'],
#         "tileCount" : tileset['tilecount'],
#         "width"     : tileset['imagewidth'],
#         "height"    : tileset['imageheight'],
#     }
#     return serialize_record(fields)

def serialize_lut(level, layer):
    lut_data = encode_tile_data((layer['width'], layer['height']), level['tileset_size'], layer['data'])
    asset = "%s.%s" % (level['name'], layer['name']), lut_data
    return serialize_tuple(asset)

def serialize_level(level):

    if level['tilesets']:
        # Just grab the first since we support one tileset only anyway
        tileset = level['tilesets'][0]
        tileset_size = tileset['columns'], (tileset['imageheight'] // tileset['tileheight'])
    else:
        raise ValueError("No tilesets found in level.")

    # Inject tileset size
    level['tileset_size'] = tileset_size

    # Pass level data first
    serialize_tile_layer_       = partial(serialize_tile_layer, level)
    serialize_obstacle_layer_   = partial(serialize_obstacle_layer, level)
    serialize_lut_              = partial(serialize_lut, level)

    # Extract relevant object groups so they are directly accessible via
    # level.groupName label. E.g.:
    #
    # import Levels.MageCity as City
    # List.map (\obstacle -> obstacle.width ...) City.level.obstacles
    obstacles = filter(is_named_object_group("Obstacles"),
        filter(is_object_layer, level['layers']))

    fields = {
        "name"          : level['name'],
        "background"    : Color(level['backgroundcolor'] if 'backgroundcolor' in level else '#000000'),
        #"tileWidth"     : level['tilewidth'],
        #"tileHeight"    : level['tileheight'],
        "layers"        : map(serialize_tile_layer_, filter(is_tile_layer, level['layers'])),
        #"tileSets"      : map(serialize_tileset,level['tilesets']),        # FIXME Hardcoded
        #"renderOrder"   : Identity("Tiled.RightDown"),
        "assets"        : map(serialize_lut_, filter(is_tile_layer, level['layers'])),
        "obstacles"     : Identity(serialize_obstacle_layer_(obstacles[0]))
    }
    return serialize_record(fields)

def is_tile_layer(layer):
    return layer['type'] == "tilelayer"

def is_object_layer(layer):
    return layer['type'] == "objectgroup"

def is_named_object_group(name):
    def _(layer):
        return layer['name'] == name
    return _

def serialize(level):
    return (BOILERPLATE % level['name']) +\
        ("level = %s" % serialize_level(level))

# Coordinate conversion

# def convert_position(order, reference_size, x, y):
#     w, h = reference_size
#     if order == RIGHT_DOWN:
#         return x, h - y
#     else:
#         raise ValueError("Unsupported rendering order" + order)

# See http://blog.tojicode.com/2012/07/sprite-tile-maps-on-gpu.html
def encode_tile_data(layer_size, tileset_size, data):
    white = 255, 255, 255

    img = Image.new('RGB', layer_size, color=white)
    for index, tile_id in enumerate(data):

        if tile_id == 0:
            continue # Empty tile

        x = index % layer_size[0]
        y = index // layer_size[0]

        # Col and row, 0-indexed
        r = (tile_id-1) % tileset_size[0]
        g = (tile_id-1) // tileset_size[0]

        img.putpixel((x, y), (r, g, 0))

    f = io.BytesIO()
    img.save(f, 'PNG')
    return 'data:image/png;base64,' + base64.b64encode(f.getvalue())

# Naive slug generator, e.g. "City 1" becomes "city-1"
def get_slug(*words):
    # def transfomer(v):
    #     return value.lower().replace(" ", "-")

    return "-".join(
        ["%s" % v.lower() for v in words]
    )

# Entry point

USAGE='%prog input.json output-dir'

def main():
    parser = OptionParser(usage=USAGE)

    _, args = parser.parse_args()
    if len(args) != 2:
        parser.error('not enough arguments given')

    input_path, output_dir = args[0], args[1]
    _, filename = os.path.split(input_path)

    with open(input_path) as f:
        name, _ = os.path.splitext(filename)

        data = json.load(f, encoding="utf-8")
        # Inject level name
        data['name'] = name
        level = serialize(data)

        # Write output level file
        with open(os.path.join(output_dir, SRC_DIR, name + ".elm"), "w") as out_f:
            out_f.write(level)
        print "Written", name , "into" , SRC_DIR

if __name__ == "__main__":
    main()
