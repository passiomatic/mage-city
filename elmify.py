# -*- coding: utf-8 -*-
import os
import sys
import json
import struct
import base64
import io
import urlparse
import itertools
from functools import partial
from optparse import OptionParser, make_option
from PIL import Image

BOILERPLATE = """
-- This file has been generated by the Elmify utility. Sample usage:
-- $ python elmify.py /path/to/YourLevel.json .
--
-- That will output ./src/Levels/YourLevel.elm. Edit SRC_DIR to change output location.

module Levels.%s exposing (..)

import Color exposing (rgb)
import Math.Vector2 exposing (vec2)
import Math.Vector3 exposing (vec3)
import Tiled exposing (Geometry(..))
import Dict

"""

SRC_DIR = 'src/Levels'

# Tiled render order
RIGHT_DOWN, RIGHT_UP, LEFT_DOWN, LEFT_UP = "right-down", "right-up", "left-down", "left-up"

# Serializers for basic Elm types

def serialize_string(v):
    return '"%s"' % v

def serialize_float(v):
    return '%f' % v

def serialize_int(v):
    return '%d' % v

def serialize_bool(v):
    return "True" if v else "False"

# Collection/aggregated types

def serialize_list(fields):
    return "[ " + ", ".join(map(str, fields)) + " ]"

def serialize_record(fields):
    l = ["%s = %s" % (k, serialize_value(v)) for (k, v) in fields.items()]
    return "{ " + ", ".join(l) + "}"

def serialize_ctor(type_, fields):
    l = ["%s" % serialize_value(field) for field in fields]
    return type_ + " " + " ".join(l)

def serialize_tuple(values):
    l = [serialize_value(v) for v in values]
    return "( " + ", ".join(l) + " )"

# Serialize a type annotation
# def serialize_type(k, v):
#     return "%s : %s" % (k, v)

# Pass value as-is
class Identity(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        return self.v

class Color(object):
    def __init__(self, v):
        self.rgb = struct.unpack('BBB', v.lstrip('#').decode('hex'))
    def serialize(self, _):
        r, g, b = self.rgb
        return 'rgb %d %d %d' % (r, g, b)
    def __str__(self):
        return self.serialize('')

class Vec2(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        x, y = self.v
        return 'vec2 %.2f %.2f' % (x, y)
    def __str__(self):
        return self.serialize('')

class Vec3(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        x, y, z = self.v
        return 'vec3 %.2f %.2f %.2f' % (x, y, z)
    def __str__(self):
        return self.serialize('')

# The top serializer, this calls all the serializers above.
#   Lists, records and tuple serializers can also call
#   serialize_value() for each element
def serialize_value(v):
    t = type(v)
    if t == str or t == unicode:
        serializer = serialize_string
    elif t == int:
        serializer = serialize_int
    elif t == float:
        serializer = serialize_float
    elif t == list:
        serializer = serialize_list
    elif t == bool:
        serializer = serialize_bool
    elif t == tuple:
        serializer = serialize_tuple
    elif t == dict:
        serializer = serialize_record
    # Special serializers
    elif t in (Color, Identity, Vec2, Vec3):
        serializer = v.serialize
    else:
        raise TypeError("Cannot find serializer for " + v)

    return serializer(v)

# Tiled stuff

def serialize_tile_layer(level, layer):

    # Convert in px
    w = layer['width'] * level['tilewidth']
    h = layer['height'] * level['tileheight']

    # Calculate absolute position form offset
    offset_x = layer['offsetx'] if 'offsetx' in layer else 0
    offset_y = layer['offsety'] if 'offsety' in layer else 0
    x = offset_x + w / 2
    y = h / 2 - offset_y
    z = get_property(layer, "z", 0.1)

    name = layer['name']

    # Save LUT data
    layer['lut'] = encode_tile_data(
        (layer['width'], layer['height']),
        level['tileset_size'], layer['data'])

    fields = {
        "name"      : "%s.%s" % (level['name'], name),
        "size"      : Vec2((w, h)),
        "position"  : Vec3((x, y, z)),
        # TODO "opacity"   : layer['opacity'],
        "isVisible"   : layer['visible'],
    }
    return serialize_record(fields)

def serialize_placeholders_layer(level, objects):

    # Convert size in pixels
    level_w = level['width'] * level['tilewidth']
    level_h = level['height'] * level['tileheight']

    def get_category(value):
        return (value if value else "Obstacle")

    def convert_object(object):

        new_object = {}

        # Check if it is a polygon
        if "polygon" in object:

            originX, originY = convert_position(level_w, level_h, object['x'], object['y'])
            converter = partial(convert_polygon_position, originX, originY)
            points = [ Vec2(converter(point['x'], point['y'])) for point in object['polygon'] ]

            geometry = {
                'points': points
            }
            new_object['geometry'] = Identity(serialize_ctor("PolygonGeometry", [geometry]))
        else:
            # Nope, assume it is a rect

            w = object['width']
            h = object['height']

            cx, cy = convert_rect_position(level['renderorder'], level_w, level_h, w, h, object['x'], object['y'])

            geometry = {
                "position": Vec2((cx, cy)),
                "size": Vec2((w, h))
            }
            new_object['geometry'] = Identity(serialize_ctor("RectangleGeometry", [geometry]))

        new_object['categoryName']  = get_category(object['type'])
        new_object['id']            = object['id']
        new_object['name']          = object['name']


        return new_object

    # Make it a list of tuples, eg. [ (id, record) ... ]
    fields = map(lambda record: serialize_tuple([record['id'], record]),
        map(convert_object, objects))
    return serialize_list(fields)


def serialize_lut(level, layer):
    lut_data = encode_tile_data((layer['width'], layer['height']),
        level['tileset_size'],
        layer['data'])
    asset = {
        "name" : "%s.%s" % (level['name'], layer['name']),
        "url" : lut_data
        }
    return serialize_record(asset)

def serialize_level(level):

    if level['tilesets']:
        # Just grab the first since we support one tileset only anyway
        tileset = level['tilesets'][0]
        tileset_size = tileset['columns'], (tileset['imageheight'] // tileset['tileheight'])
    else:
        raise ValueError("No tilesets found in level.")

    # Inject tileset size
    level['tileset_size'] = tileset_size

    # Pass level data first
    serialize_tile_layer_ = partial(serialize_tile_layer, level)
    serialize_placeholders_layer_ = partial(serialize_placeholders_layer, level)
    serialize_lut_ = partial(serialize_lut, level)

    # Extract relevant object groups so they are directly accessible
    #   via the level.groupName label.

    object_layers = filter(is_object_layer, level['layers'])
    objects = [layer['objects'] for layer in object_layers]

    # "Flatten" the list of lists,
    #  see: https://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python
    objects = list(itertools.chain.from_iterable(objects))

    fields = {
        "name"          : level['name'],
        "background"    : Color(level['backgroundcolor'] if 'backgroundcolor' in level else '#000000'),
        "layers"        : map(serialize_tile_layer_, filter(is_tile_layer, level['layers'])),
        "assets"        : map(serialize_lut_, filter(is_tile_layer, level['layers'])),
        "placeholders"  : Identity("Dict.fromList " + serialize_placeholders_layer_(objects))
    }
    return serialize_record(fields)

def is_tile_layer(layer):
    return layer['type'] == "tilelayer"

def is_object_layer(layer):
    return layer['type'] == "objectgroup"

def is_named_object_group(name):
    def _(layer):
        return layer['name'] == name
    return _

def serialize(level):
    return (BOILERPLATE % level['name']) +\
        ("level = %s" % serialize_level(level))

# Flip Y axis
def convert_position(_, level_h, x, y):
    return x, level_h - y

# Convert from rect top left coordinates (used in right-down
# render order) to level "midpoint" coordinates
def convert_rect_position(order, _, level_h, w, h, x, y):
    if order == RIGHT_DOWN:
        # Return midpoint x and midpoint Y with flipped axis
        return x + w / 2, level_h - y - h / 2
    else:
        raise ValueError("Unsupported rendering order " + order)

# Convert from polygon coordinates to level absolute coordinates
def convert_polygon_position(originX, originY, x, y):
    # Negate Y value to flip axis
    return originX + x, originY - y

def get_property(layer, name, default):
    try:
        return layer["properties"][name]
    except KeyError, ex:
        return default

# See http://blog.tojicode.com/2012/07/sprite-tile-maps-on-gpu.html
def encode_tile_data(layer_size, tileset_size, data):
    white = 255, 255, 255

    img = Image.new('RGB', layer_size, color=white)
    for index, tile_id in enumerate(data):

        if tile_id == 0:
            continue # Empty tile

        x = index % layer_size[0]
        y = index // layer_size[0]

        # Col and row, 0-indexed
        r = (tile_id-1) % tileset_size[0]
        g = (tile_id-1) // tileset_size[0]

        img.putpixel((x, y), (r, g, 0))

    f = io.BytesIO()
    img.save(f, 'PNG')
    return 'data:image/png;base64,' + base64.b64encode(f.getvalue())


# Entry point

USAGE='%prog input.json output-dir'

def main():
    parser = OptionParser(usage=USAGE)

    _, args = parser.parse_args()
    if len(args) != 2:
        parser.error('not enough arguments given')

    input_path, output_dir = args[0], args[1]
    _, filename = os.path.split(input_path)

    with open(input_path) as f:
        name, _ = os.path.splitext(filename)

        data = json.load(f, encoding="utf-8")
        # Inject level name
        data['name'] = name
        level = serialize(data)

        # Write output level file
        with open(os.path.join(output_dir, SRC_DIR, name + ".elm"), "w") as out_f:
            out_f.write(level)
        print "Written", name , "into" , SRC_DIR

if __name__ == "__main__":
    main()
