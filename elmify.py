# -*- coding: utf-8 -*-
import os
import sys
import json
import struct
import base64
import io
import urlparse
import itertools
from functools import partial
from optparse import OptionParser, make_option
from PIL import Image

BOILERPLATE = """
-- This file has been generated by the Elmify utility. Sample usage:
-- $ python elmify.py /path/to/YourLevel.json .

module Levels.%s exposing (..)

import Color exposing (rgb)
import Math.Vector2 exposing (vec2)

"""

SRC_DIR = 'src/Levels'

# Tiled render order
RIGHT_DOWN, RIGHT_UP, LEFT_DOWN, LEFT_UP = "right-down", "right-up", "left-down", "left-up"

# Serializers for basic Elm types

def serialize_string(v):
    return '"%s"' % v

def serialize_float(v):
    return '%f' % v

def serialize_int(v):
    return '%d' % v

def serialize_bool(v):
    return "True" if v else "False"

def serialize_list(fields):
    return "[" + ", ".join(map(str, fields)) + "]"

def serialize_record(fields):
    l = ["%s = %s" % (k, serialize_value(v)) for (k, v) in fields.items()]
    return "{" + ", ".join(l) + "}"

def serialize_ctor(type_, fields):
    l = ["%s" % field for field in fields]
    return type_ + " ".join(l)

def serialize_tuple(values):
    l = [serialize_value(v) for v in values]
    return "(" + ", ".join(l) + ")"

# Serialize a type annotation
def serialize_type(k, v):
    return "%s : %s" % (k, v)

# Pass value as-is
class Identity(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        return self.v

# There's no obvious mapping from Python to Elm Color
#   type, so build a translator
class Color(object):
    def __init__(self, v):
        self.rgb = struct.unpack('BBB', v.lstrip('#').decode('hex'))
    def serialize(self, _):
        r, g, b = self.rgb
        return 'rgb %d %d %d' % (r, g, b)

# There's no obvious mapping from Python to Elm Collision.Rectangle
#   type, so build a translator
class Rectangle(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        cx, cy, w, h = self.v
        return 'rectangle (vec2 %d %d) (vec2 %d %d)' % (cx, cy, w, h)

# There's no obvious mapping from Python to Elm Vec2
#   type, so build a translator
class Vec2(object):
    def __init__(self, v):
        self.v = v
    def serialize(self, _):
        w, h = self.v
        return 'vec2 %d %d' % (w, h)

# class Asset(object):
#     def __init__(self, v):
#         self.v = v
#     def serialize(self, _):
#         return serialize_tuple(self.v)

# The top serializer, this calls all the serializers above.
#   Lists, records and tuple serializers can also call
#   serialize_value() for each element
def serialize_value(v):
    t = type(v)
    if t == str or t == unicode:
        serializer = serialize_string
    elif t == int:
        serializer = serialize_int
    elif t == float:
        serializer = serialize_float
    elif t == list:
        serializer = serialize_list
    elif t == bool:
        serializer = serialize_bool
    elif t == tuple:
        serializer = serialize_tuple
    # Special serializers
    elif t in (Color, Identity, Rectangle, Vec2):
        serializer = v.serialize
    else:
        raise TypeError("Cannot find serializer for " + v)

    return serializer(v)

# Tiled stuff

def serialize_tile_layer(level, layer):

    # Convert in px
    w = layer['width'] * level['tilewidth']
    h = layer['height'] * level['tileheight']

    # Calculate absolute position form offset
    offset_x = layer['offsetx'] if 'offsetx' in layer else 0
    offset_y = layer['offsety'] if 'offsety' in layer else 0
    x = offset_x + w / 2
    y = h / 2 - offset_y

    name = layer['name']

    # Save LUT data
    layer['lut'] = encode_tile_data(
        (layer['width'], layer['height']),
        level['tileset_size'], layer['data'])

    fields = {
        "name"      : name,
        "size"      : Vec2((w, h)),
        "position"  : Vec2((x, y)),
        # TODO "opacity"   : layer['opacity'],
        "visible"   : layer['visible'],
        "lutName" : "%s.%s" % (level['name'], name)
    }
    return serialize_record(fields)

def serialize_spawns_layer(level, objects):

    # Convert size in pixels
    level_w = level['width'] * level['tilewidth']
    level_h = level['height'] * level['tileheight']

    #serialize_ctor_ = partial(serialize_ctor, "Spawn")

    def get_category(value):
        return (value if value else "Obstacle") + "Category"

    def convert_object(object):

        new_object = {}

        # Coordinate conversion
        if level['renderorder'] == RIGHT_DOWN:
            # Find center
            w   = object['width']
            h   = object['height']
            cx  = object['x'] + w / 2
            # Flip Y
            cy = level_h - object['y'] - h / 2
        else:
            raise ValueError("Unsupported rendering order " + order)

        new_object['categoryName']  = get_category(object['type'])
        new_object['id']            = object['id']
        new_object['name']          = object['name']
        new_object['position']      = Vec2((cx, cy))
        new_object['size']          = Vec2((w, h))

        return new_object

    fields = map(serialize_record,
                map(convert_object, objects))
    return serialize_list(fields)


def serialize_lut(level, layer):
    lut_data = encode_tile_data((layer['width'], layer['height']),
        level['tileset_size'],
        layer['data'])
    asset = "%s.%s" % (level['name'], layer['name']), lut_data
    return serialize_tuple(asset)

def serialize_level(level):

    if level['tilesets']:
        # Just grab the first since we support one tileset only anyway
        tileset = level['tilesets'][0]
        tileset_size = tileset['columns'], (tileset['imageheight'] // tileset['tileheight'])
    else:
        raise ValueError("No tilesets found in level.")

    # Inject tileset size
    level['tileset_size'] = tileset_size

    # Pass level data first
    serialize_tile_layer_       = partial(serialize_tile_layer, level)
    serialize_spawns_layer_     = partial(serialize_spawns_layer, level)
    serialize_lut_              = partial(serialize_lut, level)

    # Extract relevant object groups so they are directly accessible
    #   via the level.groupName label.

    object_layers = filter(is_object_layer, level['layers'])
    objects = [layer['objects'] for layer in object_layers]

    # "Flatten" the list of lists,
    #  see: https://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python
    objects = list(itertools.chain.from_iterable(objects))

    fields = {
        "name"          : level['name'],
        "background"    : Color(level['backgroundcolor'] if 'backgroundcolor' in level else '#000000'),
        "layers"        : map(serialize_tile_layer_, filter(is_tile_layer, level['layers'])),
        "assets"        : map(serialize_lut_, filter(is_tile_layer, level['layers'])),
        "spawns"        : Identity(serialize_spawns_layer_(objects))
    }
    return serialize_record(fields)

def is_tile_layer(layer):
    return layer['type'] == "tilelayer"

def is_object_layer(layer):
    return layer['type'] == "objectgroup"

def is_named_object_group(name):
    def _(layer):
        return layer['name'] == name
    return _

def serialize(level):
    return (BOILERPLATE % level['name']) +\
        ("level = %s" % serialize_level(level))

# Convert top left coordinates (used in right-down renner order)
#  to midpoint coordinates
# def convert_position(order, reference_size, x, y):
#     w, h = reference_size
#     if order == RIGHT_DOWN:
#         # Return midpoint x and midpoint Y with flipped axis
#         return x + w / 2, h - y - h / 2
#     else:
#         raise ValueError("Unsupported rendering order " + order)

# See http://blog.tojicode.com/2012/07/sprite-tile-maps-on-gpu.html
def encode_tile_data(layer_size, tileset_size, data):
    white = 255, 255, 255

    img = Image.new('RGB', layer_size, color=white)
    for index, tile_id in enumerate(data):

        if tile_id == 0:
            continue # Empty tile

        x = index % layer_size[0]
        y = index // layer_size[0]

        # Col and row, 0-indexed
        r = (tile_id-1) % tileset_size[0]
        g = (tile_id-1) // tileset_size[0]

        img.putpixel((x, y), (r, g, 0))

    f = io.BytesIO()
    img.save(f, 'PNG')
    return 'data:image/png;base64,' + base64.b64encode(f.getvalue())


# Entry point

USAGE='%prog input.json output-dir'

def main():
    parser = OptionParser(usage=USAGE)

    _, args = parser.parse_args()
    if len(args) != 2:
        parser.error('not enough arguments given')

    input_path, output_dir = args[0], args[1]
    _, filename = os.path.split(input_path)

    with open(input_path) as f:
        name, _ = os.path.splitext(filename)

        data = json.load(f, encoding="utf-8")
        # Inject level name
        data['name'] = name
        level = serialize(data)

        # Write output level file
        with open(os.path.join(output_dir, SRC_DIR, name + ".elm"), "w") as out_f:
            out_f.write(level)
        print "Written", name , "into" , SRC_DIR

if __name__ == "__main__":
    main()
